##单链表和之恋##

<h3>问题描述</h3>
<pre>
  两个单链表（singly linked list），每一个节点里面一个0-9的数字，输入就相当于两个大数了。然后返回这两个数的和（一个新list）。这两个输入的list长度相等。
  要求是：
  1、不用递归；
  2、要求算法在最好的情况下，只遍历两个list一次 ，最差的情况下两遍。</pre>


<h3>问题分析</h3>
<pre>
这是陈利人同学今天发在待字闺中的面试编程题目，看了一下解答， 发现要么需要遍历链表两次，要么需要额外的存储空间，难道就没有更优的解法了吗？ 想了一下，发现还是有的。

OK，我们把这个问题具体化一下吧：(这里就不再考虑从低到高存等blabla情况)

两个单链表，每个节点存储一个0-9的数字，那么一个单链表就表示一个大数。 从高位到低位存，即表头对应的是这个大数的最高位。两个链表的长度相等， 我们要返回一个新的单链表，是这两个输入链表代表的数的和。我们不能使用递归， 不能使用额外的存储空间，即空间复杂度是O(1)。只遍历输入链表一次， 输出链表也是单链表(没有前向指针)。

既然只能遍历两个输入链表一次，那我们就从高位加起呗。在这种限制条件下， 这是唯一的出路。然后呢？进位咋整？先加高位，再加低位， 低位产生的进位怎么加到高位去？我们可没有前向指针哦亲。既然没有前向指针， 我们就让一个临时指针指向高位，当低位相加产生进位时，我们就可以操作高位了。 让我们看看图示：

输入链表1： 1 2 3  
输入链表2： 1 2 8  
输出链表：  2 4  
两个指针：    p q  
当指向输出链表当前结点的指针q发现3+8=11，产生进位，指向高位的p就将结点值加1。 注意，两个0-9的数相加，要么不进位，要么进位为1，只有两种情况。因此， 我们不用考虑进位是其它数，这一点很重要，后面会看到的。

这样就OK了吗？当然不是，如果你遇上连续进位，怎么破？请看下面的情况：

输入链表1： 1 2 3 4 5  
输入链表2： 1 7 6 5 9
显然，指向高位的指针p总是紧跟着指向当前结点的指针q是不行的， 这样当遇上连续进位时，比p更高位的位也需要改变。既然p不能紧跟着q， 我们就不让它们紧挨着，给它们产生点距离。考虑一下，什么情况下会产生连续进位？ 9! 嗯，遇上9的时候。它要连续进位到哪一位？不为9的那一位。因此，指针p 要停留在和不为9的那一位上，看图示：

输入链表1： 1 2 3 4 5  
输入链表2： 1 7 6 5 9  
输出链表：  2 9 9 9  
两个指针：  p       q  
这回当q发现，需要进位了，只需要把p所指结点加1，然后把p，q间的结点都置0即可。 为什么都置0了呢，因为进位只可能是1，9+1=10，留在该位的自然是0了。

分析完毕，这种方法在任何时候都只需要遍历输入链表一次，空间复杂度O(1)。
</pre>
